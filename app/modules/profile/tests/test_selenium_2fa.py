# Generated by Selenium IDE
import pytest
from selenium import webdriver
from selenium.common.exceptions import TimeoutException  # Importar para manejar errores de tiempo de espera
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions as EC  # Importar condiciones esperadas
from selenium.webdriver.support.ui import WebDriverWait  # Importar para esperas explícitas


class TestKnjj:
    def setup_method(self, method):
        self.driver = webdriver.Firefox()
        self.vars = {}
        self.wait = WebDriverWait(self.driver, 10)  # Inicializar WebDriverWait con un máximo de 10 segundos

    def teardown_method(self, method):
        self.driver.quit()

    def test_knjj_invalid_2fa_code(self):
        # --- 1. PREPARACIÓN DEL ESCENARIO ---
        self.driver.get("http://127.0.0.1:5000/login")
        self.driver.set_window_size(1440, 900)

        # 1.1 Iniciar sesión
        self.driver.find_element(By.ID, "email").send_keys("user1@example.com")
        self.driver.find_element(By.ID, "password").send_keys("1234")
        self.driver.find_element(By.ID, "submit").click()

        # 1.2 Navegar a la activación de 2FA
        self.wait.until(EC.element_to_be_clickable((By.LINK_TEXT, "Edit profile"))).click()
        self.wait.until(EC.element_to_be_clickable((By.LINK_TEXT, "Enable 2FA"))).click()

        # 1.3 Ingresar código de verificación INVÁLIDO y enviarlo
        self.driver.find_element(By.NAME, "verification_code").send_keys("000000")
        self.driver.find_element(By.CSS_SELECTOR, ".btn-success:nth-child(2)").click()

        # --- 2. ASERSCIÓN CLAVE (Verificar el mensaje de error) ---

        # Define el texto del error exacto que esperas (sin la etiqueta <span>)
        EXPECTED_ERROR_TEXT = "Invalid verification code. Please try again."

        # Intenta localizar el span con el texto y esperar a que esté visible.
        # Usaremos XPath para encontrar el elemento que contiene el texto.

        # NOTA: Si el SPAN está dentro de un elemento contenedor como un div o alert:
        # Debes usar el localizador del elemento contenedor si el span no tiene ID o clase única.
        # Asumamos que el texto 'Invalid verification code...' está directamente visible en un span.

        # Si el span NO tiene una clase o ID única, usamos XPath para buscar el texto:
        error_xpath = f"//span[contains(text(), '{EXPECTED_ERROR_TEXT}')]"

        try:
            # Espera hasta que el elemento con el texto exacto aparezca
            error_element = self.wait.until(EC.visibility_of_element_located((By.XPATH, error_xpath)))

            # Opcional: Si necesitas el texto *limpio* sin espacios en blanco adicionales
            actual_text_cleaned = error_element.text.strip()

            # ASERCIÓN FINAL: El test PASA solo si el texto es exactamente el esperado
            assert actual_text_cleaned == EXPECTED_ERROR_TEXT, (
                f"El texto de error esperado no coincide. Esperado: '{EXPECTED_ERROR_TEXT}',"
                + f" Obtenido: '{actual_text_cleaned}'"
            )

            print("¡Test Passed! El mensaje de error esperado apareció correctamente.")

        except TimeoutException:
            # Si la espera expira, significa que el mensaje de error no apareció
            pytest.fail(
                f"Test Failed: El mensaje de error esperado ('{EXPECTED_ERROR_TEXT}')"
                " no apareció dentro del tiempo límite."
            )
